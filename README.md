##设计思路
	统计数据集上市公司股票代码（“stock”列）的出现次数，按出现次数从⼤到⼩输出，输出格
式为"<排名>：<股票代码>，<次数>
	我本来想用一个mapreduce任务解决这个事情，但是我只能想到用mapper来得到一系列
的<股票代码,1>这样的key-value对，那如果这样的话，reducer就又要做累加，还要进行排序
，可能负担太重了。而如果让mapper就统计好每个股票代码的出现次数的话，又有如果有多个
mapper的话，可能一个股票代码的出现次数是分布在好几个mapper中的？所以还有待进一步累加
不太能够在shuffle阶段进行自动的排序？所以我想不明白，就使用了两个mapreduce任务来解决
这个事情。
	第1个mapper是用于得到<股票代码,1>这样的键值对
	第1个reducer是用于得到<股票代码,出现次数>这样的键值对
	第2个mapper是用于得到<出现次数,股票代码>这样的键值对
	第2个reducer是用于得到<排名>：<股票代码>，<次数>

##程序运行结果
1:MS,726
2:MRK,704
3:QQQ,693
4:BABA,689
5:EWU,681
6:GILD,663
7:JNJ,663
8:MU,659
9:NVDA,655
10:VZ,648
11:KO,643
12:QCOM,636
13:M,635
14:NFLX,635
15:EBAY,621
16:DAL,605
17:WFC,582
18:BBRY,581
19:ORCL,575
20:FDX,573
21:BMY,563
22:AA,561
23:JCP,559
24:EWP,553
25:NOK,532
26:EWJ,526
27:GLD,513
28:EWI,510
29:LMT,509
30:CHK,508
31:GPRO,508
32:HD,506
33:TWX,506
34:GPS,502
35:P,501
......




##提交作业运⾏成功的WEB⻚⾯截图
![web页面截图]（/home/cookie/Pictures/Screenshots/Screenshot from 2024-10-13 16-52-33.png）

## 性能与扩展性分析
	我觉得像这样用两个mapreduce任务来处理这个事情肯定不是最好的方法，其性能可能并不最优，但是
可能对于每一个mapper和reducer而言，其任务量是不大的，而且也避免了在reducer内进行排序造成的内存不足问题，可能数据规模扩展以后还可以有较好的性能。
